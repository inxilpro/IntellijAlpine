package com.github.inxilpro.intellijalpine

import com.intellij.lang.javascript.navigation.JSGotoDeclarationHandler
import com.intellij.lang.javascript.psi.JSInheritedLanguagesHelper
import com.intellij.lang.javascript.psi.JSObjectLiteralExpression
import com.intellij.lang.javascript.psi.impl.JSPsiElementFactory
import com.intellij.openapi.editor.Editor
import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiFile
import com.intellij.psi.html.HtmlTag
import com.intellij.psi.util.elementType
import com.intellij.psi.xml.XmlElementType.HTML_TAG
import com.intellij.refactoring.suggested.startOffset
import java.util.*

class AlpineGotoDeclarationHandler : JSGotoDeclarationHandler() {

    override fun getGotoDeclarationTargets(
        sourceElement: PsiElement?,
        offset: Int,
        editor: Editor?
    ): Array<PsiElement>? {
        if (sourceElement == null) return null
        if (editor == null) return null

        val targets = super.getGotoDeclarationTargets(sourceElement, offset, editor)

        // There should only be one target
        if (targets?.size != 1) return targets

        // Check if this is a snippet generated by us.
        val header = tryParseHeader(editor.document.charsSequence.lines().first()) ?: return targets

        // Check if the found target was generated by us.
        if (targets.first().startOffset > header.startOffset.toInt()) return targets

        // Get the $data offsets for the found target.
        val dataOffset = header.dataOffsets.firstOrNull { it.expression.contains(sourceElement.text) } ?: return targets

        // Retrieve the currently opened PSI Document.
        val textEditor = editor.project?.let { FileEditorManager.getInstance(it).selectedTextEditor } ?: return null
        val document = editor.project?.let { PsiDocumentManager.getInstance(it).getCachedPsiFile(textEditor.document) }
            ?: return null

        // Finally, search for the tag referenced by our dataOffset and return it.
        return searchForTag(document, dataOffset)
            ?.let { arrayOf(it.getAttribute("x-data")?.valueElement as PsiElement) }
            ?: return targets
    }

    private fun tryParseHeader(header: String): AlpineAttributeInjectionHeader.Header? {
        return try {
            AlpineAttributeInjectionHeader.deserialize(header)
        } catch (_: Exception) {
            null
        }
    }

    private fun searchForTag(
        document: PsiFile,
        dataOffset: AlpineAttributeInjectionHeader.DataIndicesHeader
    ): HtmlTag? {
        var children = document.children.asList()
        do {
            val newChildren = Vector<PsiElement>()

            children.forEach {
                if (it.startOffset <= dataOffset.tagStartOffset) {
                    if (it.startOffset == dataOffset.tagStartOffset && it.elementType == HTML_TAG) {
                        return it as HtmlTag
                    }

                    newChildren.addAll(it.children)
                }
            }
            children = newChildren
        } while (children.isNotEmpty())

        return null
    }
}